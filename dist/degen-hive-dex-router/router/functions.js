"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = init;
exports.destroyOrTransferBalance = destroyOrTransferBalance;
exports.deployerRegisterPoolBothCoinMetadataAvailable = deployerRegisterPoolBothCoinMetadataAvailable;
exports.deployerRegisterPoolXMetadataAvailable = deployerRegisterPoolXMetadataAvailable;
exports.deployerRegisterPoolYMetadataAvailable = deployerRegisterPoolYMetadataAvailable;
exports.addLiquidityTo2pool = addLiquidityTo2pool;
exports.addLiquidityTo2poolOnlyX = addLiquidityTo2poolOnlyX;
exports.addLiquidityTo2poolOnlyXReturnBalance = addLiquidityTo2poolOnlyXReturnBalance;
exports.addLiquidityTo2poolOnlyY = addLiquidityTo2poolOnlyY;
exports.addLiquidityTo2poolOnlyYReturnBalance = addLiquidityTo2poolOnlyYReturnBalance;
exports.addLiquidityTo2poolReturnBalance = addLiquidityTo2poolReturnBalance;
exports.addLiquidityTo3pool = addLiquidityTo3pool;
exports.addLiquidityTo3poolOnlyX = addLiquidityTo3poolOnlyX;
exports.addLiquidityTo3poolOnlyXReturnBalance = addLiquidityTo3poolOnlyXReturnBalance;
exports.addLiquidityTo3poolOnlyY = addLiquidityTo3poolOnlyY;
exports.addLiquidityTo3poolOnlyYReturnBalance = addLiquidityTo3poolOnlyYReturnBalance;
exports.addLiquidityTo3poolOnlyZ = addLiquidityTo3poolOnlyZ;
exports.addLiquidityTo3poolOnlyZReturnBalance = addLiquidityTo3poolOnlyZReturnBalance;
exports.addLiquidityTo3poolReturnBalance = addLiquidityTo3poolReturnBalance;
exports.createThreeCoinVector = createThreeCoinVector;
exports.createTwoCoinVector = createTwoCoinVector;
exports.getSortedOrderThreeCoin = getSortedOrderThreeCoin;
exports.getSortedOrderTwoCoin = getSortedOrderTwoCoin;
exports.getThreeCoinOrderedWeightsAndPrices = getThreeCoinOrderedWeightsAndPrices;
exports.getTwoCoinOrderedWeightsAndPrices = getTwoCoinOrderedWeightsAndPrices;
exports.registerThreePoolAllCoinMetadataAvailable = registerThreePoolAllCoinMetadataAvailable;
exports.registerThreePoolNoMetadataAvailable = registerThreePoolNoMetadataAvailable;
exports.registerThreePoolXMetadataAvailable = registerThreePoolXMetadataAvailable;
exports.registerThreePoolXYMetadataAvailable = registerThreePoolXYMetadataAvailable;
exports.registerThreePoolXZMetadataAvailable = registerThreePoolXZMetadataAvailable;
exports.registerThreePoolYMetadataAvailable = registerThreePoolYMetadataAvailable;
exports.registerThreePoolYZMetadataAvailable = registerThreePoolYZMetadataAvailable;
exports.registerThreePoolZMetadataAvailable = registerThreePoolZMetadataAvailable;
exports.registerTwoPoolBothCoinMetadataAvailable = registerTwoPoolBothCoinMetadataAvailable;
exports.registerTwoPoolNoMetadataAvailable = registerTwoPoolNoMetadataAvailable;
exports.registerTwoPoolXMetadataAvailable = registerTwoPoolXMetadataAvailable;
exports.registerTwoPoolYMetadataAvailable = registerTwoPoolYMetadataAvailable;
exports.removeLiquidityFrom2pool = removeLiquidityFrom2pool;
exports.removeLiquidityFrom3pool = removeLiquidityFrom3pool;
exports.swap2pool = swap2pool;
exports.swap2poolProvideX = swap2poolProvideX;
exports.swap2poolProvideXReturnBalance = swap2poolProvideXReturnBalance;
exports.swap2poolProvideY = swap2poolProvideY;
exports.swap2poolProvideYReturnBalance = swap2poolProvideYReturnBalance;
exports.swap2poolReturnBalance = swap2poolReturnBalance;
exports.swap3pool = swap3pool;
exports.swap3poolProvidex = swap3poolProvidex;
exports.swap3poolProvidexReturnBalance = swap3poolProvidexReturnBalance;
exports.swap3poolProvidey = swap3poolProvidey;
exports.swap3poolProvideyReturnBalance = swap3poolProvideyReturnBalance;
exports.swap3poolProvidez = swap3poolProvidez;
exports.swap3poolProvidezReturnBalance = swap3poolProvidezReturnBalance;
exports.swap3poolReturnBalance = swap3poolReturnBalance;
const __1 = require("..");
const PUBLISHED_AT = __1.dex.PUBLISHED_AT;
const CLOCK = __1.dex.CLOCK;
const TWO_POOL_REGISTRY = __1.dex.TWO_POOL_REGISTRY;
const THREE_POOL_REGISTRY = __1.dex.THREE_POOL_REGISTRY;
const YIELD_FLOW = __1.dex.YIELD_FLOW;
const SUI_FEE_COLLECTOR = __1.dex.SUI_FEE_COLLECTOR;
const util_1 = require("../../_framework/util");
function init(tx) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::init`, arguments: [], }); }
function destroyOrTransferBalance(tx, typeArg, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::destroy_or_transfer_balance`, typeArguments: [typeArg], arguments: [(0, util_1.obj)(tx, args.balance), (0, util_1.pure)(tx, args.recipient, `address`)], }); }
function deployerRegisterPoolBothCoinMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::deployer_register_pool_both_coin_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.cap), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, TWO_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataX), (0, util_1.obj)(tx, args.metadataY), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function deployerRegisterPoolXMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::deployer_register_pool_x_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.cap), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, TWO_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataX), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function deployerRegisterPoolYMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::deployer_register_pool_y_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.cap), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, TWO_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataY), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function addLiquidityTo2pool(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_2pool`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinX), (0, util_1.pure)(tx, args.coinXVal, `u64`), (0, util_1.obj)(tx, args.coinY), (0, util_1.pure)(tx, args.coinYVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo2poolOnlyX(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_2pool_only_x`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinX), (0, util_1.pure)(tx, args.coinXVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo2poolOnlyXReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_2pool_only_x_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinX), (0, util_1.pure)(tx, args.coinXVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo2poolOnlyY(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_2pool_only_y`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinY), (0, util_1.pure)(tx, args.coinYVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo2poolOnlyYReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_2pool_only_y_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinY), (0, util_1.pure)(tx, args.coinYVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo2poolReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_2pool_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinX), (0, util_1.pure)(tx, args.coinXVal, `u64`), (0, util_1.obj)(tx, args.coinY), (0, util_1.pure)(tx, args.coinYVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo3pool(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_3pool`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinX), (0, util_1.pure)(tx, args.coinXVal, `u64`), (0, util_1.obj)(tx, args.coinY), (0, util_1.pure)(tx, args.coinYVal, `u64`), (0, util_1.obj)(tx, args.coinZ), (0, util_1.pure)(tx, args.coinZVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo3poolOnlyX(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_3pool_only_x`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinX), (0, util_1.pure)(tx, args.coinXVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo3poolOnlyXReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_3pool_only_x_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinX), (0, util_1.pure)(tx, args.coinXVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo3poolOnlyY(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_3pool_only_y`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinY), (0, util_1.pure)(tx, args.coinYVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo3poolOnlyYReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_3pool_only_y_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinY), (0, util_1.pure)(tx, args.coinYVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo3poolOnlyZ(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_3pool_only_z`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinZ), (0, util_1.pure)(tx, args.coinZVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo3poolOnlyZReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_3pool_only_z_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinZ), (0, util_1.pure)(tx, args.coinZVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function addLiquidityTo3poolReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::add_liquidity_to_3pool_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinX), (0, util_1.pure)(tx, args.coinXVal, `u64`), (0, util_1.obj)(tx, args.coinY), (0, util_1.pure)(tx, args.coinYVal, `u64`), (0, util_1.obj)(tx, args.coinZ), (0, util_1.pure)(tx, args.coinZVal, `u64`), (0, util_1.pure)(tx, args.minLpMinted, `u64`)], }); }
function createThreeCoinVector(tx, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::create_three_coin_vector`, arguments: [(0, util_1.pure)(tx, args.x, `u8`), (0, util_1.pure)(tx, args.y, `u8`), (0, util_1.pure)(tx, args.z, `u8`)], }); }
function createTwoCoinVector(tx, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::create_two_coin_vector`, arguments: [(0, util_1.pure)(tx, args.x, `u8`), (0, util_1.pure)(tx, args.y, `u8`)], }); }
function getSortedOrderThreeCoin(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::get_sorted_order_three_coin`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.pure)(tx, args.indexX, `u8`), (0, util_1.pure)(tx, args.indexY, `u8`), (0, util_1.pure)(tx, args.indexZ, `u8`)], }); }
function getSortedOrderTwoCoin(tx, typeArgs) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::get_sorted_order_two_coin`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, YIELD_FLOW)], }); }
function getThreeCoinOrderedWeightsAndPrices(tx, typeArg, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::get_three_coin_ordered_weights_and_prices`, typeArguments: [typeArg], arguments: [(0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`), (0, util_1.pure)(tx, args.sortedOrder, `vector<u8>`)], }); }
function getTwoCoinOrderedWeightsAndPrices(tx, typeArg, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::get_two_coin_ordered_weights_and_prices`, typeArguments: [typeArg], arguments: [(0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerThreePoolAllCoinMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_three_pool_all_coin_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, THREE_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataX), (0, util_1.obj)(tx, args.metadataY), (0, util_1.obj)(tx, args.metadataZ), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerThreePoolNoMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_three_pool_no_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, THREE_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerThreePoolXMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_three_pool_x_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, THREE_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataX), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerThreePoolXYMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_three_pool_x_y_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, THREE_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataX), (0, util_1.obj)(tx, args.metadataY), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerThreePoolXZMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_three_pool_x_z_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, THREE_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataX), (0, util_1.obj)(tx, args.metadataZ), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerThreePoolYMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_three_pool_y_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, THREE_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataY), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerThreePoolYZMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_three_pool_y_z_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, THREE_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataY), (0, util_1.obj)(tx, args.metadataZ), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerThreePoolZMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_three_pool_z_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, THREE_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataZ), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerTwoPoolBothCoinMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_two_pool_both_coin_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, TWO_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataX), (0, util_1.obj)(tx, args.metadataY), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerTwoPoolNoMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_two_pool_no_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, TWO_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerTwoPoolXMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_two_pool_x_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, TWO_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataX), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function registerTwoPoolYMetadataAvailable(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::register_two_pool_y_metadata_available`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, YIELD_FLOW), (0, util_1.obj)(tx, TWO_POOL_REGISTRY), (0, util_1.obj)(tx, args.fee), (0, util_1.obj)(tx, SUI_FEE_COLLECTOR), (0, util_1.obj)(tx, args.metadataY), (0, util_1.pure)(tx, args.initParams, `vector<u64>`), (0, util_1.pure)(tx, args.initialPrices, `vector<u256>`), (0, util_1.pure)(tx, args.weights, `vector<u64>`)], }); }
function removeLiquidityFrom2pool(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::remove_liquidity_from_2pool`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.lpCoin), (0, util_1.pure)(tx, args.lpCoinVal, `u64`), (0, util_1.pure)(tx, args.coinXOutVal, `u64`), (0, util_1.pure)(tx, args.coinYOutVal, `u64`), (0, util_1.pure)(tx, args.maxLpCoinsToBurn, `u64`)], }); }
function removeLiquidityFrom3pool(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::remove_liquidity_from_3pool`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.lpCoin), (0, util_1.pure)(tx, args.lpCoinVal, `u64`), (0, util_1.pure)(tx, args.coinXOutVal, `u64`), (0, util_1.pure)(tx, args.coinYOutVal, `u64`), (0, util_1.pure)(tx, args.coinZOutVal, `u64`), (0, util_1.pure)(tx, args.maxLpCoinsToBurn, `u64`)], }); }
function swap2pool(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap2pool`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinXIn), (0, util_1.pure)(tx, args.xIn, `u64`), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.obj)(tx, args.coinYIn), (0, util_1.pure)(tx, args.yIn, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap2poolProvideX(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap2pool_provide_x`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.tokenXIn), (0, util_1.pure)(tx, args.xInAmt, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap2poolProvideXReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap2pool_provide_x_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.tokenXIn), (0, util_1.pure)(tx, args.xInAmt, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap2poolProvideY(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap2pool_provide_y`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.obj)(tx, args.tokenYIn), (0, util_1.pure)(tx, args.yInAmt, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap2poolProvideYReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap2pool_provide_y_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.obj)(tx, args.tokenYIn), (0, util_1.pure)(tx, args.yInAmt, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap2poolReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap2pool_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinXIn), (0, util_1.pure)(tx, args.xIn, `u64`), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.obj)(tx, args.coinYIn), (0, util_1.pure)(tx, args.yIn, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap3pool(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap3pool`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinXIn), (0, util_1.pure)(tx, args.xIn, `u64`), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.obj)(tx, args.coinYIn), (0, util_1.pure)(tx, args.yIn, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.obj)(tx, args.coinZIn), (0, util_1.pure)(tx, args.zIn, `u64`), (0, util_1.pure)(tx, args.zOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap3poolProvidex(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap3pool_provideX`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinXIn), (0, util_1.pure)(tx, args.xInAmt, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.pure)(tx, args.zOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap3poolProvidexReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap3pool_provideX_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinXIn), (0, util_1.pure)(tx, args.xInAmt, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.pure)(tx, args.zOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap3poolProvidey(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap3pool_provideY`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.obj)(tx, args.coinYIn), (0, util_1.pure)(tx, args.yInAmt, `u64`), (0, util_1.pure)(tx, args.zOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap3poolProvideyReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap3pool_provideY_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.obj)(tx, args.coinYIn), (0, util_1.pure)(tx, args.yInAmt, `u64`), (0, util_1.pure)(tx, args.zOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap3poolProvidez(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap3pool_provideZ`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.obj)(tx, args.coinZIn), (0, util_1.pure)(tx, args.zInAmt, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap3poolProvidezReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap3pool_provideZ_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.obj)(tx, args.coinZIn), (0, util_1.pure)(tx, args.zInAmt, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
function swap3poolReturnBalance(tx, typeArgs, args) { return tx.moveCall({ target: `${PUBLISHED_AT}::router::swap3pool_return_balance`, typeArguments: typeArgs, arguments: [(0, util_1.obj)(tx, CLOCK), (0, util_1.obj)(tx, args.pool), (0, util_1.obj)(tx, args.coinXIn), (0, util_1.pure)(tx, args.xIn, `u64`), (0, util_1.pure)(tx, args.xOutMin, `u64`), (0, util_1.obj)(tx, args.coinYIn), (0, util_1.pure)(tx, args.yIn, `u64`), (0, util_1.pure)(tx, args.yOutMin, `u64`), (0, util_1.obj)(tx, args.coinZIn), (0, util_1.pure)(tx, args.zIn, `u64`), (0, util_1.pure)(tx, args.zOutMin, `u64`), (0, util_1.pure)(tx, args.isGiveIn, `bool`)], }); }
